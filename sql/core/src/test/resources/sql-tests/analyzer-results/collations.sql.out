-- Automatically generated by SQLQueryTestSuite
-- !query
create table t1(utf8_binary string collate utf8_binary, utf8_binary_lcase string collate utf8_binary_lcase) using parquet
-- !query analysis
CreateDataSourceTableCommand `spark_catalog`.`default`.`t1`, false


-- !query
insert into t1 values('aaa', 'aaa')
-- !query analysis
InsertIntoHadoopFsRelationCommand file:[not included in comparison]/{warehouse_dir}/t1, false, Parquet, [path=file:[not included in comparison]/{warehouse_dir}/t1], Append, `spark_catalog`.`default`.`t1`, org.apache.spark.sql.execution.datasources.InMemoryFileIndex(file:[not included in comparison]/{warehouse_dir}/t1), [utf8_binary, utf8_binary_lcase]
+- Project [cast(col1#x as string) AS utf8_binary#x, cast(col2#x as string collate UTF8_BINARY_LCASE) AS utf8_binary_lcase#x]
   +- LocalRelation [col1#x, col2#x]


-- !query
insert into t1 values('AAA', 'AAA')
-- !query analysis
InsertIntoHadoopFsRelationCommand file:[not included in comparison]/{warehouse_dir}/t1, false, Parquet, [path=file:[not included in comparison]/{warehouse_dir}/t1], Append, `spark_catalog`.`default`.`t1`, org.apache.spark.sql.execution.datasources.InMemoryFileIndex(file:[not included in comparison]/{warehouse_dir}/t1), [utf8_binary, utf8_binary_lcase]
+- Project [cast(col1#x as string) AS utf8_binary#x, cast(col2#x as string collate UTF8_BINARY_LCASE) AS utf8_binary_lcase#x]
   +- LocalRelation [col1#x, col2#x]


-- !query
insert into t1 values('bbb', 'bbb')
-- !query analysis
InsertIntoHadoopFsRelationCommand file:[not included in comparison]/{warehouse_dir}/t1, false, Parquet, [path=file:[not included in comparison]/{warehouse_dir}/t1], Append, `spark_catalog`.`default`.`t1`, org.apache.spark.sql.execution.datasources.InMemoryFileIndex(file:[not included in comparison]/{warehouse_dir}/t1), [utf8_binary, utf8_binary_lcase]
+- Project [cast(col1#x as string) AS utf8_binary#x, cast(col2#x as string collate UTF8_BINARY_LCASE) AS utf8_binary_lcase#x]
   +- LocalRelation [col1#x, col2#x]


-- !query
insert into t1 values('BBB', 'BBB')
-- !query analysis
InsertIntoHadoopFsRelationCommand file:[not included in comparison]/{warehouse_dir}/t1, false, Parquet, [path=file:[not included in comparison]/{warehouse_dir}/t1], Append, `spark_catalog`.`default`.`t1`, org.apache.spark.sql.execution.datasources.InMemoryFileIndex(file:[not included in comparison]/{warehouse_dir}/t1), [utf8_binary, utf8_binary_lcase]
+- Project [cast(col1#x as string) AS utf8_binary#x, cast(col2#x as string collate UTF8_BINARY_LCASE) AS utf8_binary_lcase#x]
   +- LocalRelation [col1#x, col2#x]


-- !query
select count(*) from t1 group by utf8_binary
-- !query analysis
Aggregate [utf8_binary#x], [count(1) AS count(1)#xL]
+- SubqueryAlias spark_catalog.default.t1
   +- Relation spark_catalog.default.t1[utf8_binary#x,utf8_binary_lcase#x] parquet


-- !query
select count(*) from t1 group by utf8_binary_lcase
-- !query analysis
Aggregate [utf8_binary_lcase#x], [count(1) AS count(1)#xL]
+- SubqueryAlias spark_catalog.default.t1
   +- Relation spark_catalog.default.t1[utf8_binary#x,utf8_binary_lcase#x] parquet


-- !query
select * from t1 where utf8_binary = 'aaa'
-- !query analysis
Project [utf8_binary#x, utf8_binary_lcase#x]
+- Filter (utf8_binary#x = aaa)
   +- SubqueryAlias spark_catalog.default.t1
      +- Relation spark_catalog.default.t1[utf8_binary#x,utf8_binary_lcase#x] parquet


-- !query
select * from t1 where utf8_binary_lcase = 'aaa' collate utf8_binary_lcase
-- !query analysis
Project [utf8_binary#x, utf8_binary_lcase#x]
+- Filter (utf8_binary_lcase#x = collate(aaa, utf8_binary_lcase))
   +- SubqueryAlias spark_catalog.default.t1
      +- Relation spark_catalog.default.t1[utf8_binary#x,utf8_binary_lcase#x] parquet


-- !query
select * from t1 where utf8_binary < 'bbb'
-- !query analysis
Project [utf8_binary#x, utf8_binary_lcase#x]
+- Filter (utf8_binary#x < bbb)
   +- SubqueryAlias spark_catalog.default.t1
      +- Relation spark_catalog.default.t1[utf8_binary#x,utf8_binary_lcase#x] parquet


-- !query
select * from t1 where utf8_binary_lcase < 'bbb' collate utf8_binary_lcase
-- !query analysis
Project [utf8_binary#x, utf8_binary_lcase#x]
+- Filter (utf8_binary_lcase#x < collate(bbb, utf8_binary_lcase))
   +- SubqueryAlias spark_catalog.default.t1
      +- Relation spark_catalog.default.t1[utf8_binary#x,utf8_binary_lcase#x] parquet


-- !query
select l.utf8_binary, r.utf8_binary_lcase from t1 l join t1 r on l.utf8_binary_lcase = r.utf8_binary_lcase
-- !query analysis
Project [utf8_binary#x, utf8_binary_lcase#x]
+- Join Inner, (utf8_binary_lcase#x = utf8_binary_lcase#x)
   :- SubqueryAlias l
   :  +- SubqueryAlias spark_catalog.default.t1
   :     +- Relation spark_catalog.default.t1[utf8_binary#x,utf8_binary_lcase#x] parquet
   +- SubqueryAlias r
      +- SubqueryAlias spark_catalog.default.t1
         +- Relation spark_catalog.default.t1[utf8_binary#x,utf8_binary_lcase#x] parquet


-- !query
create table t2(utf8_binary string collate utf8_binary, utf8_binary_lcase string collate utf8_binary_lcase) using parquet
-- !query analysis
CreateDataSourceTableCommand `spark_catalog`.`default`.`t2`, false


-- !query
insert into t2 values('aaa', 'aaa')
-- !query analysis
InsertIntoHadoopFsRelationCommand file:[not included in comparison]/{warehouse_dir}/t2, false, Parquet, [path=file:[not included in comparison]/{warehouse_dir}/t2], Append, `spark_catalog`.`default`.`t2`, org.apache.spark.sql.execution.datasources.InMemoryFileIndex(file:[not included in comparison]/{warehouse_dir}/t2), [utf8_binary, utf8_binary_lcase]
+- Project [cast(col1#x as string) AS utf8_binary#x, cast(col2#x as string collate UTF8_BINARY_LCASE) AS utf8_binary_lcase#x]
   +- LocalRelation [col1#x, col2#x]


-- !query
insert into t2 values('bbb', 'bbb')
-- !query analysis
InsertIntoHadoopFsRelationCommand file:[not included in comparison]/{warehouse_dir}/t2, false, Parquet, [path=file:[not included in comparison]/{warehouse_dir}/t2], Append, `spark_catalog`.`default`.`t2`, org.apache.spark.sql.execution.datasources.InMemoryFileIndex(file:[not included in comparison]/{warehouse_dir}/t2), [utf8_binary, utf8_binary_lcase]
+- Project [cast(col1#x as string) AS utf8_binary#x, cast(col2#x as string collate UTF8_BINARY_LCASE) AS utf8_binary_lcase#x]
   +- LocalRelation [col1#x, col2#x]


-- !query
select * from t1 anti join t2 on t1.utf8_binary_lcase = t2.utf8_binary_lcase
-- !query analysis
Project [utf8_binary#x, utf8_binary_lcase#x]
+- Join LeftAnti, (utf8_binary_lcase#x = utf8_binary_lcase#x)
   :- SubqueryAlias spark_catalog.default.t1
   :  +- Relation spark_catalog.default.t1[utf8_binary#x,utf8_binary_lcase#x] parquet
   +- SubqueryAlias spark_catalog.default.t2
      +- Relation spark_catalog.default.t2[utf8_binary#x,utf8_binary_lcase#x] parquet


-- !query
drop table t2
-- !query analysis
DropTable false, false
+- ResolvedIdentifier V2SessionCatalog(spark_catalog), default.t2


-- !query
drop table t1
-- !query analysis
DropTable false, false
+- ResolvedIdentifier V2SessionCatalog(spark_catalog), default.t1


-- !query
create table t1 (c1 struct<utf8_binary: string collate utf8_binary, utf8_binary_lcase: string collate utf8_binary_lcase>) USING PARQUET
-- !query analysis
CreateDataSourceTableCommand `spark_catalog`.`default`.`t1`, false


-- !query
INSERT INTO t1 VALUES (named_struct('utf8_binary', 'aaa', 'utf8_binary_lcase', 'aaa'))
-- !query analysis
InsertIntoHadoopFsRelationCommand file:[not included in comparison]/{warehouse_dir}/t1, false, Parquet, [path=file:[not included in comparison]/{warehouse_dir}/t1], Append, `spark_catalog`.`default`.`t1`, org.apache.spark.sql.execution.datasources.InMemoryFileIndex(file:[not included in comparison]/{warehouse_dir}/t1), [c1]
+- Project [named_struct(utf8_binary, col1#x.utf8_binary, utf8_binary_lcase, cast(col1#x.utf8_binary_lcase as string collate UTF8_BINARY_LCASE)) AS c1#x]
   +- LocalRelation [col1#x]


-- !query
INSERT INTO t1 VALUES (named_struct('utf8_binary', 'AAA', 'utf8_binary_lcase', 'AAA'))
-- !query analysis
InsertIntoHadoopFsRelationCommand file:[not included in comparison]/{warehouse_dir}/t1, false, Parquet, [path=file:[not included in comparison]/{warehouse_dir}/t1], Append, `spark_catalog`.`default`.`t1`, org.apache.spark.sql.execution.datasources.InMemoryFileIndex(file:[not included in comparison]/{warehouse_dir}/t1), [c1]
+- Project [named_struct(utf8_binary, col1#x.utf8_binary, utf8_binary_lcase, cast(col1#x.utf8_binary_lcase as string collate UTF8_BINARY_LCASE)) AS c1#x]
   +- LocalRelation [col1#x]


-- !query
select count(*) from t1 group by c1.utf8_binary
-- !query analysis
Aggregate [c1#x.utf8_binary], [count(1) AS count(1)#xL]
+- SubqueryAlias spark_catalog.default.t1
   +- Relation spark_catalog.default.t1[c1#x] parquet


-- !query
select count(*) from t1 group by c1.utf8_binary_lcase
-- !query analysis
Aggregate [c1#x.utf8_binary_lcase], [count(1) AS count(1)#xL]
+- SubqueryAlias spark_catalog.default.t1
   +- Relation spark_catalog.default.t1[c1#x] parquet


-- !query
drop table t1
-- !query analysis
DropTable false, false
+- ResolvedIdentifier V2SessionCatalog(spark_catalog), default.t1
